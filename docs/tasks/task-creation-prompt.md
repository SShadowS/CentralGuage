# CentralGauge Task Creation Guide

You are being asked to create benchmark tasks for **CentralGauge**, an open-source benchmark for evaluating LLMs on AL (Application Language) code generation for Microsoft Dynamics 365 Business Central.

## Your Goal

Create challenging but fair benchmark tasks that test whether LLMs truly understand AL syntax, semantics, and Business Central conventions - not just pattern matching.

---

## What is AL?

AL (Application Language) is the programming language for Microsoft Dynamics 365 Business Central. It's used to create:

- **Tables** - Data storage with fields, keys, triggers, and relations
- **Pages** - User interfaces (Cards, Lists, API pages)
- **Codeunits** - Business logic containers
- **Reports** - Data extraction and presentation
- **Enums** - Type-safe option values
- **Interfaces** - Contract definitions for polymorphism
- **Table Extensions** - Extend existing tables with new fields
- **Page Extensions** - Extend existing pages with new controls/actions
- **XMLports** - Data import/export
- **Queries** - SQL-like data retrieval

---

## Task YAML Format

Each task is defined in a `.yml` file with this structure:

```yaml
id: CG-AL-XXXX # Unique ID (E=Easy, M=Medium, H=Hard)
prompt_template: code-gen.md # Always use this
fix_template: bugfix.md # Always use this
max_attempts: 2 # Always 2 (first attempt + one retry)
description: >-
  Clear description of what to build.
  Include specific requirements:
  - Object names and IDs
  - Field names, types, and constraints
  - Procedure signatures
  - Expected behaviors
  - Error messages (exact text if validation is tested)
expected:
  compile: true
  testApp: tests/al/{difficulty}/CG-AL-XXXX.Test.al
metrics:
  - compile_pass
  - tests_pass
  - pass_attempt
```

### ID Format

- `CG-AL-E###` - Easy tasks (001-999)
- `CG-AL-M###` - Medium tasks (001-999)
- `CG-AL-H###` - Hard tasks (001-999)

### File Naming

- Task YAML: `tasks/{difficulty}/CG-AL-{ID}-{short-name}.yml`
- Test file: `tests/al/{difficulty}/CG-AL-{ID}.Test.al`
- Helper files: `tests/al/{difficulty}/CG-AL-{ID}.{HelperName}.al`

---

## Test File Format

Tests are AL codeunits that verify the LLM's generated code works correctly.

### Basic Structure

```al
codeunit 80XXX "CG-AL-XXXX Test"
{
    Subtype = Test;
    TestPermissions = Disabled;

    var
        Assert: Codeunit Assert;
        LibraryRandom: Codeunit "Library - Random";

    [Test]
    procedure TestName()
    var
        // Variables
    begin
        // [SCENARIO] What we're testing
        // [GIVEN] Initial conditions
        // [WHEN] Action taken
        // [THEN] Expected result

        // Actual test code with assertions
    end;
}
```

### Test Codeunit IDs

- Easy tests: 80001-80099
- Medium tests: 80100-80199
- Hard tests: 80200-80299

### Helper Object IDs

- Mock codeunits/enums: 70090-70099

---

## Helper Files

Some tasks require helper objects that are provided to the LLM (not generated by it).

### Mock Implementations (for interface tests)

```al
codeunit 70096 "CG-AL-E008 Mock Processor" implements "Payment Processor"
{
    procedure ProcessPayment(Amount: Decimal; PaymentMethod: Text): Boolean
    begin
        exit(Amount > 0);  // Simple mock logic
    end;

    // ... other interface methods
}
```

### Enums (provided dependencies)

```al
enum 70098 "CG Product Type"
{
    Extensible = false;

    value(0; Standard) { Caption = 'Standard'; }
    value(1; Food) { Caption = 'Food'; }
    value(2; Books) { Caption = 'Books'; }
}
```

---

## Difficulty Levels

### Easy (CG-AL-E###)

**What makes it Easy:**

- Single object creation
- Standard patterns with minimal complexity
- Basic syntax knowledge
- Few or no edge cases

**Examples:**

- Create a simple table with 3-4 fields
- Create a basic enum with options
- Create a page for an existing table
- Create a simple codeunit with one procedure
- Create a basic interface definition
- Create a simple table extension

### Medium (CG-AL-M###)

**What makes it Medium:**

- Multiple related objects
- Complex validation logic
- Triggers with business rules
- Error handling requirements
- Cross-object interactions
- API pages with CRUD operations

**Examples:**

- Table with complex validation triggers (date ranges, status transitions)
- Multi-object scenarios (table + page + codeunit)
- Interface implementation
- Reports with calculations
- Workflow-like state machines
- Integration scenarios with HTTP calls

### Hard (CG-AL-H###)

**What makes it Hard:**

- Complex conditional logic with many branches
- Multiple interacting rules
- Precise mathematical calculations
- Boundary condition handling
- Country/region-specific logic
- Performance-sensitive operations
- Advanced patterns (dependency injection, events)

**Examples:**

- Tax calculator with tiered rates by country and product type
- Multi-currency conversion with rounding rules
- Complex discount engines
- Inventory costing algorithms
- Posting routines with multiple validations

---

## Critical Rules for Task Descriptions

### DO NOT Add Guidance or Hints

**BAD - This guides the model:**

```yaml
description: >-
  Create an interface called "Payment Processor"
  (note: interfaces in AL do not use numeric IDs)
```

**GOOD - This tests the model's knowledge:**

```yaml
description: >-
  Create an interface called "Payment Processor"
```

If a model incorrectly adds an ID to an interface, that's a valid test failure - it shows the model doesn't understand AL syntax.

### DO Specify Exact Error Messages

If you're testing validation, specify the exact error message:

```yaml
description: >-
  OnDelete trigger to prevent deletion of Active contracts.
  Error message must be exactly: "Cannot delete active contract"
```

This allows precise test assertions.

### DO Specify Field Types and Names Exactly

```yaml
description: >-
  Fields:
  - Contract No. (Code[20], primary key)
  - Customer No. (Code[20], with TableRelation to Customer)
  - Start Date (Date)
  - Contract Value (Decimal)
```

### DO Specify Procedure Signatures Exactly

```yaml
description: >-
  CalculateTax(Amount: Decimal; CountryCode: Code[2]; ProductType: Enum "CG Product Type"): Decimal
```

---

## Critical Rules for Tests

### NEVER Use Placeholder Assertions

**BAD:**

```al
[Test]
procedure TestSomething()
begin
    Assert.IsTrue(true, 'This always passes');  // USELESS
end;
```

**GOOD:**

```al
[Test]
procedure TestSomething()
var
    Result: Decimal;
begin
    Result := Calculator.Add(2, 3);
    Assert.AreEqual(5, Result, 'Addition should return correct sum');
end;
```

### Test Everything Specified

If the task says "Active field defaults to true", test it:

```al
[Test]
procedure TestActiveDefaultValue()
var
    ProductCategory: Record "Product Category";
    TestCode: Code[20];
begin
    TestCode := CopyStr(LibraryRandom.RandText(10), 1, 20);
    ProductCategory.Init();
    ProductCategory.Code := TestCode;
    ProductCategory.Description := 'Test';
    ProductCategory."Created Date" := WorkDate();
    // Note: Active NOT explicitly set

    ProductCategory.Insert(true);

    Clear(ProductCategory);
    ProductCategory.Get(TestCode);
    Assert.IsTrue(ProductCategory.Active, 'Active should default to true via InitValue');

    ProductCategory.Delete();
end;
```

### Test Boundary Conditions

If the task says "tax is 7% for amounts >= 100 and < 1000":

```al
[Test]
procedure TestUS_JustBelowLowerThreshold_NoTax()
begin
    // $99.99 should have 0% tax
    Result := TaxCalculator.CalculateTax(99.99, 'US', "CG Product Type"::Standard);
    Assert.AreEqual(0, Result, 'US amount 99.99 should have 0% tax');
end;

[Test]
procedure TestUS_ExactlyAtLowerThreshold_7Percent()
begin
    // $100 exactly should have 7% tax
    Result := TaxCalculator.CalculateTax(100, 'US', "CG Product Type"::Standard);
    Assert.AreEqual(7, Result, 'US amount exactly 100 should have 7% tax');
end;
```

### Test Edge Cases

- Negative amounts
- Zero amounts
- Empty strings
- Unknown/invalid codes
- Maximum length strings

### Interface Tests Need Mock Implementations

Interfaces can't be instantiated directly:

```al
[Test]
procedure TestProcessPayment()
var
    PaymentProcessor: Interface "Payment Processor";
    MockProcessor: Codeunit "CG-AL-E008 Mock Processor";
begin
    PaymentProcessor := MockProcessor;
    Assert.IsTrue(PaymentProcessor.ProcessPayment(100.00, 'Card'), 'Should process');
end;
```

---

## AL Object Types Reference

### Table

```al
table 70000 "Product Category"
{
    Caption = 'Product Category';
    DataClassification = CustomerContent;

    fields
    {
        field(1; "Code"; Code[20])
        {
            Caption = 'Code';
            NotBlank = true;
        }
        field(2; Description; Text[100])
        {
            Caption = 'Description';
        }
        field(3; Active; Boolean)
        {
            Caption = 'Active';
            InitValue = true;
        }
    }

    keys
    {
        key(PK; "Code") { Clustered = true; }
    }

    trigger OnInsert()
    begin
        // Insert logic
    end;
}
```

### Page (Card)

```al
page 70000 "Product Category Card"
{
    PageType = Card;
    SourceTable = "Product Category";
    Caption = 'Product Category Card';
    ApplicationArea = All;
    UsageCategory = Documents;

    layout
    {
        area(Content)
        {
            group(General)
            {
                field("Code"; Rec."Code") { }
                field(Description; Rec.Description) { }
            }
        }
    }
}
```

### Codeunit

```al
codeunit 70000 "Calculator"
{
    Access = Public;

    procedure Add(A: Decimal; B: Decimal): Decimal
    begin
        exit(A + B);
    end;
}
```

### Enum

```al
enum 70000 "Order Status"
{
    Extensible = true;

    value(0; Draft) { Caption = 'Draft'; }
    value(1; Released) { Caption = 'Released'; }
    value(2; Shipped) { Caption = 'Shipped'; }
}
```

### Interface (NO ID!)

```al
interface "Payment Processor"
{
    Access = Public;

    procedure ProcessPayment(Amount: Decimal; PaymentMethod: Text): Boolean;
    procedure ValidatePayment(PaymentData: Text): Boolean;
}
```

### Table Extension

```al
tableextension 70000 "Item Extension" extends Item
{
    fields
    {
        field(70000; "Warranty Period"; Integer)
        {
            Caption = 'Warranty Period';
            DataClassification = CustomerContent;
        }
    }
}
```

### Event Subscriber

```al
codeunit 70001 "Item Event Subscriber"
{
    Access = Internal;

    [EventSubscriber(ObjectType::Table, Database::Item, 'OnAfterInsertEvent', '', false, false)]
    local procedure OnAfterInsertItem(var Rec: Record Item)
    begin
        Message('Item %1 created', Rec."No.");
    end;
}
```

---

## Ideas for Challenging Tasks

### Test AL-Specific Knowledge

- Interfaces don't have IDs (unlike most AL objects)
- CalcFormula syntax for flowfields
- TableRelation with conditions
- Proper trigger usage (OnValidate, OnInsert, OnModify, OnDelete)
- Option vs Enum differences
- FlowField vs normal field behaviors

### Test Business Central Conventions

- Proper naming conventions (spaces, quotes)
- Caption requirements
- ApplicationArea and UsageCategory
- Proper use of Rec vs xRec
- TestPermissions in test codeunits

### Test Complex Logic

- Multi-condition validations
- State machines (Draft -> Active -> Completed)
- Calculations with rounding
- Date arithmetic
- Currency conversions
- Tiered pricing/tax rules

### Test Error Handling

- Specific error messages
- Error vs Confirm dialogs
- Try functions
- Transaction handling

---

## Output Format

For each task you create, provide:

### 1. Task YAML File

```yaml
id: CG-AL-XXXX
prompt_template: code-gen.md
fix_template: bugfix.md
max_attempts: 2
description: >-
  [Your task description here]
expected:
  compile: true
  testApp: tests/al/{difficulty}/CG-AL-XXXX.Test.al
metrics:
  - compile_pass
  - tests_pass
  - pass_attempt
```

### 2. Test AL File

```al
codeunit 80XXX "CG-AL-XXXX Test"
{
    Subtype = Test;
    TestPermissions = Disabled;

    // Your test procedures here
}
```

### 3. Helper Files (if needed)

Any mock implementations, enums, or other supporting objects.

---

## Checklist Before Submitting

- [ ] Task ID is unique and follows format (CG-AL-E/M/H###)
- [ ] Description specifies exact names, types, and signatures
- [ ] Description does NOT include hints or guidance
- [ ] Test codeunit has proper ID in range
- [ ] All assertions verify actual computed values (no `Assert.IsTrue(true, ...)`)
- [ ] Tests cover all requirements from description
- [ ] Tests cover boundary conditions and edge cases
- [ ] Helper files provided if task involves interfaces or external dependencies
- [ ] Error messages match exactly between task description and test assertions

---

## Example Complete Task

### Task YAML (`tasks/easy/CG-AL-E020-discount-calculator.yml`)

```yaml
id: CG-AL-E020
prompt_template: code-gen.md
fix_template: bugfix.md
max_attempts: 2
description: >-
  Create a codeunit called "Discount Calculator" with ID 70010.

  Implement a procedure:
  CalculateDiscount(OrderAmount: Decimal; CustomerTier: Option Standard,Silver,Gold): Decimal

  Discount rules:
  - Standard customers: No discount (0%)
  - Silver customers: 5% discount
  - Gold customers: 10% discount

  The procedure should return the discount AMOUNT (not the discounted price).
  Negative order amounts should return 0.

  Include Access = Public on the codeunit.
expected:
  compile: true
  testApp: tests/al/easy/CG-AL-E020.Test.al
metrics:
  - compile_pass
  - tests_pass
  - pass_attempt
```

### Test File (`tests/al/easy/CG-AL-E020.Test.al`)

```al
codeunit 80020 "CG-AL-E020 Test"
{
    Subtype = Test;
    TestPermissions = Disabled;

    var
        Assert: Codeunit Assert;
        DiscountCalculator: Codeunit "Discount Calculator";

    [Test]
    procedure TestStandardCustomer_NoDiscount()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(100, 0); // Standard = 0
        Assert.AreEqual(0, Result, 'Standard customers should get 0% discount');
    end;

    [Test]
    procedure TestSilverCustomer_5Percent()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(100, 1); // Silver = 1
        Assert.AreEqual(5, Result, 'Silver customers should get 5% discount = 5');
    end;

    [Test]
    procedure TestGoldCustomer_10Percent()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(200, 2); // Gold = 2
        Assert.AreEqual(20, Result, 'Gold customers should get 10% discount = 20');
    end;

    [Test]
    procedure TestNegativeAmount_ReturnsZero()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(-100, 2);
        Assert.AreEqual(0, Result, 'Negative amounts should return 0');
    end;

    [Test]
    procedure TestZeroAmount_ReturnsZero()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(0, 2);
        Assert.AreEqual(0, Result, 'Zero amount should return 0 discount');
    end;

    [Test]
    procedure TestLargeAmount_Gold()
    var
        Result: Decimal;
    begin
        Result := DiscountCalculator.CalculateDiscount(9999.99, 2);
        Assert.AreEqual(999.999, Result, 'Large amount gold discount should be 999.999');
    end;
}
```

---

Now create new benchmark tasks! Aim for variety - different object types, different difficulty levels, and tasks that test knowledge models might NOT have seen as frequently in training data.
